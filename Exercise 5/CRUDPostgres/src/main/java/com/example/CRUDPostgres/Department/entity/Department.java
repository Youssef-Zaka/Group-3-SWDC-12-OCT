package com.example.CRUDPostgres.Department.entity;

import com.example.CRUDPostgres.Employee.entity.Employee;
import com.example.CRUDPostgres.Shared.Auditable;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.util.Set;

/**
 * Represents a department entity in the system.
 * Extends the {@link Auditable} class to include auditing fields.
 */
@Entity
@Table(name = "department", uniqueConstraints = @UniqueConstraint(columnNames = "name"))
@Data // Generates getters, setters, toString, equals, and hashCode methods
@EqualsAndHashCode(callSuper = false) // Excludes superclass fields in equals and hashCode
@NoArgsConstructor // Generates a no-argument constructor
@AllArgsConstructor // Generates an all-arguments constructor
public class Department extends Auditable {

    /**
     * The unique identifier for each department.
     * Automatically generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * The name of the department.
     * Must be at least 2 characters long and cannot be blank.
     * A unique constraint is applied at the database level.
     */
    @NotBlank(message = "Department name cannot be blank")
    @Size(min = 2, message = "Name must be at least 2 characters long")
    private String name;

    /**
     * A set of employees that belong to this department.
     * The relationship is mapped by the "department" field in the {@link Employee} class.
     * Cascade type PERSIST ensures that when a department is saved, the employees
     * in the set are also persisted.
     */
    @OneToMany(mappedBy = "department", cascade = CascadeType.PERSIST)
    private Set<Employee> employees;
}
